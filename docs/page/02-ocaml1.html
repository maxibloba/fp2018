<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>page-header</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/fp2018/lib/reveal.js/css/theme/solarized.css" />
  <link rel="stylesheet" href="/fp2018/lib/kw.css" />
  <link rel="stylesheet" href="/fp2018/lib/kw-page.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="introduction-to-ocaml">Introduction to OCaml</h1>
<ul>
<li>Expressions</li>
<li>Names</li>
<li>Types</li>
<li>Functions</li>
</ul>
<h2 id="about-ocaml">About OCaml</h2>
<ul>
<li><a href="https://ocaml.org/learn/description.html">ocaml.org</a></li>
<li><a href="https://ocaml.org/docs/cheat_sheets.html">Cheat sheets</a></li>
<li><a href="https://ocaml.org/learn/taste.html">Code examples</a></li>
<li><a href="https://ocaml.org/learn/tutorials/99problems.html">99 basic problems in OCaml</a></li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html">Official tutorial (The core languages)</a>: This class follows this material</li>
</ul>
<h2 id="basics">Basics</h2>
<ul>
<li><p>Expression</p>
<p><code>1+2*3</code></p></li>
<li><p>Introduction of name (<code>let</code>), binding a value to a name</p>
<p><code>let pi = 4.0 *. atan 1.0</code></p></li>
<li><p>Function definition</p>
<p><code>let square x = x *. x</code></p></li>
<li><p>Function call and standard functions (<em>sin</em>, <em>cos</em>)</p>
<p><code>square (sin pi) +. square (cos pi)</code></p></li>
<li><p>Failure during type checking</p>
<p><code>1.0 * 2</code></p></li>
<li><p>Recursive defined functions (<code>let rec</code>)</p>
<pre><code>let rec fib n =
  if n &lt; 2 then n else fib (n-1) + fib (n-2)
  fib 10</code></pre></li>
</ul>
<h2 id="data-types">Data types</h2>
<ul>
<li><p>Logical values (<code>true</code> and <code>false</code>) and <code>bool</code> type</p>
<pre><code># (1 &lt; 2);;
- : bool = true</code></pre></li>
<li><p>Characters and <code>char</code> type</p>
<pre><code># &#39;a&#39;;;
- : char = &#39;a&#39;</code></pre></li>
<li><p>Strings and <code>string</code> type</p>
<p>`“Hello world”</p></li>
<li><p>Lists and <code>... list</code> type</p>
<pre><code># let l = [&quot;is&quot;; &quot;a&quot;; &quot;tale&quot;; &quot;told&quot;; &quot;etc.&quot;];;
val l : string list = [&quot;is&quot;; &quot;a&quot;; &quot;tale&quot;; &quot;told&quot;; &quot;etc.&quot;]</code></pre></li>
<li><p>List constructor (<code>::</code>)</p>
<pre><code># &quot;Life&quot; :: l;;
- : string list = [&quot;Life&quot;; &quot;is&quot;; &quot;a&quot;; &quot;tale&quot;; &quot;told&quot;; &quot;etc.&quot;]</code></pre></li>
<li><p>Pattern matching (application to sorting)</p>
<pre><code>let rec sort lst =
  match lst with
    [] -&gt; []
  | head :: tail -&gt; insert head (sort tail)
and insert elt lst =
  match lst with
    [] -&gt; [elt]
  | head :: tail -&gt; if elt &lt;= head then elt :: lst else head :: insert elt tail
sort l</code></pre></li>
</ul>
<h2 id="functions-as-values">Functions as values</h2>
<ul>
<li><p><code>deriv</code>: numerical derivation, <code>function</code> syntax is used to construct an unnamed function（a λ expression.</p>
<pre><code>let deriv f dx = function x -&gt; (f (x +. dx) -. f x) /. dx</code></pre></li>
<li><p><code>sin'</code>: Derivative of the sin function</p>
<p>Note: <code>'</code> can be a part of a name.</p>
<pre><code>let sin&#39; = deriv sin 1e-6
sin&#39; pi</code></pre></li>
<li><p>Function composition (<code>compose</code>) is a typical use case of higher-order functions.</p>
<pre><code>let compose f g = function x -&gt; f (g x)</code></pre></li>
<li><p>In the following, <code>cos2</code> denotes the square of <code>cos</code> function</p>
<pre><code>let cos2 = compose square cos</code></pre>
<p>A <em>higher-order function</em> is a function that takes a function as an argument or gives a function as its return value. For example, a standard function <code>List.map</code> is a higher-order function that takes a function and a list and returns a list whose elements results from application of the function to each element of the list.</p>
<pre><code># List.map (function n -&gt; n * 2 + 1) [0;1;2;3;4];;
- : int list = [1; 3; 5; 7; 9]</code></pre></li>
<li><p>An equivalent of <code>List.map</code> can be easily defined as follows:</p>
<pre><code>let rec map f l =
match l with
  [] -&gt; []
  | hd :: tl -&gt; f hd :: map f tl</code></pre></li>
</ul>
<h1 id="records">Records</h1>
<p><em>Record</em>s are compound data structure that comprises of values. Each element of a record can be dereferenced by a <em>label</em> (or <em>field</em>). (There is another compound data type called tuples. We will discuss about the tuple type later.)</p>
<ul>
<li><p>Declaration of a record type. An instance of the <code>ratio</code> type consists of two integer values. They are addressed by their names, <code>num</code> and <code>denom</code>.</p>
<pre><code>type ratio = {num: int; denom: int}</code></pre></li>
<li><p>An element of record is addressed by its label (or field name):</p>
<pre><code>let add_ratio r1 r2 =
  {num = r1.num * r2.denom + r2.num * r1.denom;
   denom = r1.denom * r2.denom}</code></pre></li>
<li><p>A record can be created and used on the fly without binding it to a name. In the following example, two instances of the <code>ratio</code> type is created and immediately passed to the <code>add_ratio</code> function.</p>
<pre><code>add_ratio {num=1; denom=3} {num=2; denom=5}</code></pre></li>
</ul>
<h1 id="variants">Variants</h1>
<p><em>Variant</em> type is sometimes called <em>tagged union</em>. In the following example, we define a variant type called <code>number</code> whose instance is either an integer value, float value, or an error.</p>
<pre><code># type number = Int of int | Float of float | Error;;
type number = Int of int | Float of float | Error
# Int 7;;
- : number = Int 7
# Float 3.14;;
- : number = Float 3.14
# Error;;
- : number = Error</code></pre>
<p>The tags of a variant type, such as <code>Int</code>, <code>Float</code>, and <code>Error</code>, are called <em>constructors</em> of the variant.</p>
<p>Some constructors take arguments. In the above example, the <code>Int</code> constructor takes an integer, while the <code>Float</code> constructor takes a floating point number.</p>
<p>Some constructors do take no argument. In the above example, the <code>Error</code> constructor takes no argument and creates an instance of the <code>number</code> variant. A variant that consists of argument-free constructors resembles <em>enum</em> type in C programming language.</p>
<pre><code>type sign = Positive | Negative</code></pre>
<p>A variants is a (first class) value. It can be bound to a name (<code>let n = Int 3</code>), passed to a function as an argument, and be a return value of a function.</p>
<pre><code>let sign_int n = if n &gt;= 0 then Positive else Negative</code></pre>
<p>In C, we use the <strong>switch</strong> statement to test a tagged union value. In OCaml, pattern matching is used for testing variant values.</p>
<pre><code>let add_num n1 n2 =
  match (n1, n2) with
    (Int i1, Int i2) -&gt;
      (* Check for overflow of integer addition *)
      if sign_int i1 = sign_int i2 &amp;&amp; sign_int (i1 + i2) &lt;&gt; sign_int i1
      then Float(float i1 +. float i2)
      else Int(i1 + i2)
  | (Int i1, Float f2) -&gt; Float(float i1 +. f2)
  | (Float f1, Int i2) -&gt; Float(f1 +. float i2)
  | (Float f1, Float f2) -&gt; Float(f1 +. f2)
  | (Error, _) -&gt; Error
  | (_, Error) -&gt; Error</code></pre>
<p>Let’s test the <code>add_num</code> function:</p>
<pre><code>add_num (Int 123) (Float 3.14159)</code></pre>
<p>The tree type is an important data structure but in some programming language its definition can be troublesome. In OCaml its definition is this easy.</p>
<pre><code>type &#39;a btree = Empty | Node of &#39;a * &#39;a btree * &#39;a btree</code></pre>
<p>A function that manipulates of trees can be simply defined by use of pattern matching.</p>
<pre><code>let rec member x btree =
  match btree with
    Empty -&gt; false
  | Node(y, left, right) -&gt;
      if x = y then true else
      if x &lt; y then member x left else member x right</code></pre>
<pre><code>let rec insert x btree =
  match btree with
    Empty -&gt; Node(x, Empty, Empty)
  | Node(y, left, right) -&gt;
      if x &lt;= y then Node(y, insert x left, right)
                else Node(y, left, insert x right)</code></pre>
<hr />
<p>#Assignments</p>
<p><code>assignment1.ml</code>というファイルに以下の課題の答を記述し、OCW-i を介して提出しなさい。〆切はOCW-iに記載する。</p>
<p>Question should be addressed on <a href="https://github.com/wakita/fp2015/issues/1">a Github issue page</a> (you need a Github account to do so).</p>
<h2 id="assignment-1-tree-manipulation-tree.ml">Assignment 1: Tree manipulation (tree.ml)</h2>
<ul>
<li><p>Give a definition of the <code>size</code> function, which counts the number of <code>Node</code> in the tree.</p></li>
<li><p>Give a definition of the <code>height</code> function, which takes a <code>btree</code>-typed tree and gives its height. <code>height Empty</code> should be 0.</p></li>
</ul>
<h2 id="assignment-2-gray-code-gray.ml">Assignment 2: Gray code (gray.ml)</h2>
<p>The following is a sequence of the <em>N-bit gray code</em> for smaller <em>N</em>s. Examine this sequence and figure out the general rule that generates gray code in the general cases. Describe the rule in OCaml.</p>
<p>gray 0 = [] gray 1 = [[0]; [1]] gray 2 = [[0; 0]; [0; 1]; [1; 1]; [1; 0]] gray 3 = [[0; 0; 0]; [0; 0; 1]; [0; 1; 1]; [0; 1; 0]; [1; 1; 0]; [1; 1; 1]; [1; 0; 1]; [1; 0; 0]]</p>
<!--
## Assignment 3: every2 (every2.ml)

Define a function named `every_next` that takes a tree of `'a bteee` and gives a list that consists of the elements in the tree that appears in the odd positions of the tree leaves.

```
every_next: 'a btree -> 'a list

every_next (Node(1, Node(2, Empty, Empty), Node(3, Empty, Node(4, Empty, Empty)))) = [2, 3]
```
-->
<hr />
<p><strong>Back to <a href="/fp2018/page/">Top</a></strong></p>
</body>
</html>
